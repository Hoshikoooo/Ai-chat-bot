import aiohttp
import io
import re
import asyncio
import json
import hashlib
import random
import string
from urllib.parse import quote
from datetime import datetime
from fake_useragent import UserAgent

from utilities.config_loader import load_current_language, config

current_language = load_current_language()
internet_access = config['INTERNET_ACCESS']


class ChatCompletion:
    @classmethod
    def md5(cls, text):
        return hashlib.md5(text.encode()).hexdigest()[::-1]

    @classmethod
    def get_api_key(cls, user_agent):
        part1 = str(random.randint(0, 10 ** 11))
        part2 = cls.md5(user_agent + cls.md5(user_agent + cls.md5(user_agent + part1 + "x")))
        return f"tryit-{part1}-{part2}"

    @classmethod
    def create(cls, messages):
        user_agent = UserAgent().random
        api_key = cls.get_api_key(user_agent)
        headers = {
            "api-key": api_key,
            "user-agent": user_agent
        }
        files = {
            "chat_style": (None, "chat"),
            "chatHistory": (None, json.dumps(messages))
        }

        async def response_chunks():
            async with aiohttp.ClientSession() as session:
                async with session.post("https://api.deepai.org/chat_response",
                                        headers=headers,
                                        data=files,
                                        raise_for_status=True,
                                        timeout=aiohttp.ClientTimeout(total=30),
                                        ) as response:
                    while True:
                        chunk = await response.content.readany()
                        if not chunk:
                            break
                        yield chunk.decode()

        return response_chunks()


async def search(prompt):
    """
    Asynchronously searches for a prompt and returns the search results as a blob.

    Args:
        prompt (str): The prompt to search for.

    Returns:
        str: The search results as a blob.

    Raises:
        None
    """
    if not internet_access or len(prompt) > 200:
        return

    search_results_limit = config['MAX_SEARCH_RESULTS']

    url_match = re.search(r'(https?://\S+)', prompt)
    if url_match:
        search_query = url_match.group(0)
    else:
        search_query = prompt

    if search_query is not None and len(search_query) > 200:
        return

    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    blob = f"Search results for: '{search_query}' at {current_time}:\n"

    if search_query is not None:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get('https://ddg-api.herokuapp.com/search',
                                       params={'query': search_query, 'limit': search_results_limit}) as response:
                    search = await response.json()
        except aiohttp.ClientError as e:
            print(f"An error occurred during the search request: {e}")
            return

        for index, result in enumerate(search):
            try:
                blob += f'[{index}] "{result["snippet"]}"\n\nURL: {result["link"]}\n'
            except Exception as e:
                blob += f'Search error: {e}\n'

        blob += "\nSearch results allow you to have real-time information and the ability to browse the internet. " \
                "As the links were generated by the system rather than the user, please send a response along with " \
                "the link if necessary.\n"
        return blob
    else:
        blob = "No search query is needed for a response"

    return blob


async def generate_response(instructions, search, history, filecontent):
    if filecontent is None:
        filecontent = 'No extra files sent.'

    if search is not None:
        search_results = search
    elif search is None:
        search_results = "Search feature is disabled"

    await asyncio.sleep(2)  # Don't overwhelm the API :)

    messages = [
        {"role": "system", "name": "instructions", "content": instructions},
        {"role": "system", "name": "search_results", "content": search_results},
        *history,
        {"role": "system", "name": "file_content", "content": filecontent},
    ]

    response_chunks = ChatCompletion.create(messages)
    response = ''

    async for chunk in response_chunks:
        response += chunk

    return response


async def generate_image(caption):
    """
    Asynchronously generates an image based on the given caption.

    Args:
        caption (str): The caption for the image.

    Returns:
        bytes: The bytes of the generated image.

    Raises:
        None
    """
    if not internet_access:
        return None

    endpoint = '/api/image-generator/v1/images'
    headers = {
        'Content-Type': 'application/json',
    }
    data = {
        'caption': caption,
    }

    for base_url in base_urls:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(base_url + endpoint, headers=headers, json=data) as response:
                    response_data = await response.json()
                    if 'image' in response_data:
                        image_bytes = response_data['image']
                        return io.BytesIO(image_bytes)
                    else:
                        print(f"Image generation failed. Response: {response_data}")
                        return None
        except aiohttp.ClientError:
            continue

    return None


async def poly_image_gen(text):
    if not internet_access:
        return None

    endpoint = '/api/text-to-image/v1/text-to-image'
    headers = {
        'Content-Type': 'application/json',
    }
    data = {
        'text': text,
    }

    for base_url in base_urls:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(base_url + endpoint, headers=headers, json=data) as response:
                    response_data = await response.json()
                    if 'image' in response_data:
                        image_bytes = response_data['image']
                        return io.BytesIO(image_bytes)
                    else:
                        print(f"Image generation failed. Response: {response_data}")
                        return None
        except aiohttp.ClientError:
            continue

    return None
